C: https://naipc18.kattis.com/problems/flashingfluorescents Surprisingly easy given the # of solves. Brute force over which timestamp you'll be done on (it's pretty clear it can't be more than 32). Now you can apply the moves all at once instead of tracking which moves are active (if you make a move with T seconds left, it flips T lights). Now the DP state (state of lights, time left) is small enough (2**16 * 32 or so). Using a map for the DP was too slow for me.

D: https://naipc18.kattis.com/problems/missinggnomes The easiest problem. Just merge (as in mergesort) the given sequence and its complement.

E: https://naipc18.kattis.com/problems/prefixfreecode This breaks down into a few independent steps: 1) Sort the strings 2) Figure out which strings make up the test string 3) Now you have a k-tuple of integers from 1..n, and you want to figure out its lexicographic order. This is relatively standard: go through index by index, figure out which option you took (for this part I used a fenwick tree; is there an easier way?), and add to your rank the number of previous options times the number of ways to fill out the rest given we chose a previous option.

For #1 and #2, I used string hashing (https://www.reddit.com/r/usaco/comments/39qrta/string_hashing/). That's all you need for the sort. For #2, binary search for each component string (since they're sorted now!)

H: https://naipc18.kattis.com/problems/recovery The parity of the whole matrix must be the parity of the row + column parities. So if those don't match, it's impossible. Otherwise, it's always possible. One construction that works and is pretty close to the desired answer is to fill everything but the first row and column with 1s. Fill in the last cell of each row and column according to its parity. (0,0) will come out the same for the row and the column (that's what the earlier whole-matrix parity check was for).

Unfortunately, this may not have the maximum number of 1s. You can "flip" the four corners of any rectangle and not disturb any parities (are all matrices satisfying the conditions connected by this operation? Not sure). If you have a 0 in the the first row and a zero in the first column you improve the solution by flipping that rectangle; all other rectangles are bad. Start with the bottom-most row zeroes and the right-most column zeroes (you might run out of one or the other; starting with the ones furthest from the corner gives the lexicographically minimal solution). Because only the first row and column potentially start with 0s, there are never other rectangles to flip. It's not totally clear to me why this is optimal.

I: https://naipc18.kattis.com/problems/redblacktree Tree DP! Define ways(x) := a vector whose kth entry is the number of subsets of the subtree rooted at x satisfying the conditions for k. It helps (it helped me, anyway) to think of this as a polynomial in k. Then combining different subtrees is just multiplying polynomials. The answer for a tree is just the multiplication of all its children plus 1 or x depending on whether the node is red or not.

A key optimization/observation is that the number of red nodes (and hence the degree of polynomials you're multiplying) is relatively small. It's important to do O(degree) work when multiplying rather than O(m) work (I think).

K: https://naipc18.kattis.com/problems/zoninghouses Range trees! Build a static range tree on the inputs (X and Y separately) storing the two minimum and two maximum values on each segment. To do a query, get the minimums and maximums for X and Y and try deleting each of the 4 extremal points (deleting other points does nothing). Building the tree is O(n); queries are O(log n).